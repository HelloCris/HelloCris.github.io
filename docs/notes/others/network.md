# 网络【todo】

## 基础概念

### 浏览器从输入URL到显示页面的过程

::: info 流程

> 1. 用户输入 URL 并回车
> 2. DNS 解析
> 3. 建立 TCP 连接，发起 HTTP 请求
> 4. 服务器处理并返回响应
> 5. 浏览器接收响应并开始解析
> 6. 布局（Layout / Reflow）
> 7. 绘制
> 8. 合成（Composite）
> 9. 后续资源加载与交互

:::

#### 第 1 步：用户输入 URL 并回车

- 浏览器解析输入内容：
  - 如果是关键词（如 “天气”），可能走默认搜索引擎；
  - 如果是合法 URL（如 `https://github.com/`），进入下一步。

#### 第 2 步：DNS 解析（将域名转为 IP 地址）

**浏览器检查缓存顺序：**

DNS缓存 -> 本地Hosts文件 -> 向本地DNS服务器发起查询 -> 若未命中，递归查询根域名服务器/顶级域（.com）/权威DNS服务器

- 最终获得目标服务器的 **IP 地址**（如 `20.205.243.166`）

#### 第 3 步：建立 TCP 连接，发起 HTTP 请求

- 浏览器通过 **TCP 协议** 与服务器 IP 建立连接（默认端口 80/HTTP 或 443/HTTPS）。
- 浏览器构造 HTTP 请求报文
- 通过已建立的 TCP（或 QUIC）连接发送请求。

#### 第 4 步：服务器处理并返回响应

- 服务器收到请求后：
  - 路由匹配
  - 执行后端逻辑（如查询数据库）
  - 生成 HTML 内容
- 返回 HTTP 响应

#### 第 5 步：浏览器接收响应并开始解析

1. 解析 HTML 构建 DOM 树
   - 浏览器逐字节解析 HTML，遇到标签就创建 DOM 节点。
   - **遇到 `<script>`**：
     - 若无 `async`/`defer`：**阻塞 HTML 解析**，立即下载并执行 JS。
     - `defer`：延迟到 DOM 解析完后执行（按顺序）。
     - `async`：异步下载，下载完立即执行（不保证顺序）。
   - **遇到 `<link rel="stylesheet">`**：
     - CSS 不阻塞 HTML 解析，但**阻塞 DOM 渲染**（因需构建 CSSOM）。

2. 加载 CSS 并构建 CSSOM
   - 下载 CSS 文件 → 解析 → 构建 **CSSOM（CSS Object Model）**
   - CSSOM 与 DOM 结合形成 **Render Tree（渲染树）**

3. 构建 Render Tree
   - Render Tree = DOM + CSSOM（只包含可见元素，如 `display: none` 的节点会被剔除）

#### 第 6 步：布局（Layout / Reflow）

- 计算每个 Render Tree 节点的**几何信息**（位置、大小）。这个过程也叫 **Reflow**。根节点（viewport）开始，递归计算。

#### 第 7 步：绘制（Paint / Rasterization）

- 将 Render Tree 转换为屏幕上的像素。
- 分层（Layer）处理：如 transform、opacity 元素会提升为单独图层。
- 绘制指令发送给 GPU（合成阶段）。

#### 第 8 步：合成（Composite）

- 浏览器将多个图层**按顺序合并**，生成最终图像。
- 由 **Compositor 线程**完成，不阻塞主线程。
- 显示在屏幕上。

> ✅ 至此，**首屏内容已渲染完成（First Paint / First Contentful Paint）**

#### 第 9 步：后续资源加载与交互

- 执行 JS（如 `DOMContentLoaded` 事件触发）
- 加载图片、视频、字体等非关键资源
- 执行 `window.onload`（所有资源加载完毕）
- 用户可交互（如点击按钮、滚动）

### 网络层级

| 层数 | 名称                    | 核心功能                                     | 前端是否关心？    | 关联前端场景                                                           |
| ---- | ----------------------- | -------------------------------------------- | ----------------- | ---------------------------------------------------------------------- |
| 7    | 应用层（Application）   | 提供用户接口和网络服务（如 HTTP、FTP、SMTP） | ✅ 高度相关       | `fetch()`、`XMLHttpRequest`、WebSocket、API 调用、浏览器地址栏访问网页 |
| 6    | 表示层（Presentation）  | 数据格式转换、加密解密、压缩                 | ⚠️ 间接相关       | HTTPS 中的 TLS 加密（如证书、AES）、JSON/XML 编码、图片压缩（WebP）    |
| 5    | 会话层（Session）       | 建立、管理和终止会话（对话控制）             | ⚠️ 基本不直接接触 | 登录会话（Session ID）、WebSocket 长连接维持（可视为会话）             |
| 4    | 传输层（Transport）     | 端到端通信、可靠传输（TCP）或快速传输（UDP） | ⚠️ 需了解概念     | TCP 保证请求完整到达；HTTP/HTTPS 基于 TCP；WebSocket 也基于 TCP        |
| 3    | 网络层（Network）       | 路由选择、IP 寻址                            | ❌ 不关心         | IP 地址分配、路由器转发（由操作系统/网络设备处理）                     |
| 2    | 数据链路层（Data Link） | 同一局域网内设备通信（MAC 地址）             | ❌ 不关心         | Wi-Fi、以太网帧传输（底层硬件处理）                                    |
| 1    | 物理层（Physical）      | 传输比特流（电压、光信号等）                 | ❌ 完全无关       | 网线、光纤、无线信号                                                   |

| 应用层协议 | 作用                                       | 前端场景                                     |
| ---------- | ------------------------------------------ | -------------------------------------------- |
| HTTP/HTTPS | 获取 HTML、CSS、JS、图片、API 数据         | 所有页面加载和 Ajax 请求                     |
| WebSocket  | 双向实时通信                               | 聊天、股票行情、在线协作                     |
| DNS        | 将域名（如 `api.example.com`）转为 IP 地址 | 影响首屏加载速度，可通过 `dns-prefetch` 优化 |

### 客户端 & 服务端

### ip地址/域名/DNS

## TCP/UDP协议

### TCP协议

### UDP协议

## HTTP/HTTPS协议

### HTTP协议

### HTTPS协议

### 请求方式

### 状态码

### 请求头与响应头

### HTTP版本

## 同源策略与跨域(CORS)

### 同源策略

### 跨域问题

## 前端发起网络请求

### AJAX

### Fetch

## 认证与会话管理

### cookie

### session

## 缓存机制

### 强缓存

### 协商缓存

## 网络安全

### XSS攻击

### CSRF攻击

### CSP内容安全策略

## 性能优化中的网络技巧
